(load "./4.2.ss")

(define primitive-procedures
  (list (list 'car-primitive car)
        (list 'cdr-primitive cdr)
        (list 'cons-primitive cons)
        (list 'null? null?)
        (list '+ +)
        (list '- -)
        (list '* *)
        (list '/ /)
        (list '= =)
        (list '< <)
        (list '> >)
        (list 'display display)
        (list 'newline newline)
        (list 'assoc assoc)
        (list 'eq? eq?)
        (list 'equal? equal?)
        (list 'list list)
        (list 'map map)
        ;...
        ))

(define the-global-environment (setup-environment))

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp env))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp)
         (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((let? exp)
         (eval (let->combination exp) env))
        ((let*? exp)
         (eval (let*->nested-lets exp) env))
        ((letrec? exp)
         (eval (letrec->let exp) env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((and? exp) (eval-and exp env))
        ((or? exp) (eval-or exp env))
        ((while? exp) (eval (while->if exp) env))
        ((application? exp)
         (apply (actual-value (operator exp) env)
                (operands exp)
                env))
        (else
          (error "Unknown expression type -- EVAL" exp))))

(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        ((null? exp) true)
        (else false)))

(define (text-of-quotation exp env)
  (if (pair? (cadr exp))
      (eval (make-quotation-list (cadr exp)) env)
      (list 'quote (cadr exp))))

(define (make-quotation-list l)
  (cond 
    ((null? l) '())
    ((pair? l)
     (list 'cons (list 'quote (car l))
           (make-quotation-list (cdr l))))
    (else (list 'quote l))))


(actual-value
  '(begin
     (define (cons x y)
       (cons-primitive 'cons (lambda (m) (m x y))))
     (define (car z)
       ((cdr-primitive z) (lambda (p q) p)))
     (define (cdr z)
       ((cdr-primitive z) (lambda (p q) q))))
  the-global-environment)

(define (user-print object)
  (if (compound-procedure? object)
    (display
      (list 'compound-procedure
            (procedure-parameters object)
            (procedure-body object)
            '<procedure-env>))
    (if (tagged-list? object ''cons)
      (display-cons object)
      (display object))))

(define (display-cons obj)
  (define (iter obj depth)
    (let ((user-car (lambda (z)
                      (force-it (lookup-variable-value 'x (procedure-environment (cdr z))))))
          (user-cdr (lambda (z)
                      (force-it (lookup-variable-value 'y (procedure-environment (cdr z)))))))
      (cond
        ((>= depth 10)
         (display "...)"))
        (else
          (if (= 0 depth)
            (display "("))
          (let ((car-value (user-car obj))
                (cdr-value (user-cdr obj)))
            (user-print (user-car obj))
            (cond
              ((tagged-list? cdr-value 'cons)
                   (display " ")
                   (iter cdr-value (+ depth 1)))
              ((null? cdr-value)
               (display ")"))
              (else
                (display " . ")
                (user-print cdr-value))))))))
  (iter obj 0))

(driver-loop)
'()
'(a b c)
'(a b c d e f g h i j k l m n o p)
(car '(a b c))
(cdr '(a b c))
(car '(a (b c)))
(cdr '(a (b c)))
(car '(a (b . c)))
(cdr '(a (b . c)))
(car  (cdr '(a (b . c))))
(car  (car  (cdr '(a (b . c)))))
(car  (cdr '(a (b . c))))
(cdr  (cdr '(a (b . c))))
end
